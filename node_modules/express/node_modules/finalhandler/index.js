/*!
 * finalhandler
<<<<<<< HEAD
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
=======
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module dependencies.
 * @private
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
 */

var debug = require('debug')('finalhandler')
var escapeHtml = require('escape-html')
var http = require('http')
<<<<<<< HEAD

/**
 * Variables.
=======
var onFinished = require('on-finished')
var unpipe = require('unpipe')

/**
 * Module variables.
 * @private
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }
<<<<<<< HEAD

/**
 * Module exports.
=======
var isFinished = onFinished.isFinished

/**
 * Module exports.
 * @public
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
 */

module.exports = finalhandler

/**
<<<<<<< HEAD
 * Final handler:
=======
 * Create a function to handle the final response.
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
 *
 * @param {Request} req
 * @param {Response} res
 * @param {Object} [options]
 * @return {Function}
<<<<<<< HEAD
 * @api public
 */

function finalhandler(req, res, options) {
  options = options || {}

  // get environment
  var env = options.env || process.env.NODE_ENV || 'development'

  // get error callback
  var onerror = options.onerror

  return function (err) {
    var msg

    // unhandled error
    if (err) {
      // default status code to 500
      if (!res.statusCode || res.statusCode < 400) {
        res.statusCode = 500
=======
 * @public
 */

function finalhandler(req, res, options) {
  var opts = options || {}

  // get environment
  var env = opts.env || process.env.NODE_ENV || 'development'

  // get error callback
  var onerror = opts.onerror

  return function (err) {
    var status = res.statusCode

    // ignore 404 on in-flight response
    if (!err && res._header) {
      debug('cannot 404 after headers sent')
      return
    }

    // unhandled error
    if (err) {
      // respect err.statusCode
      if (err.statusCode) {
        status = err.statusCode
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
      }

      // respect err.status
      if (err.status) {
<<<<<<< HEAD
        res.statusCode = err.status
=======
        status = err.status
      }

      // default status code to 500
      if (!status || status < 400) {
        status = 500
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
      }

      // production gets a basic error message
      var msg = env === 'production'
<<<<<<< HEAD
        ? http.STATUS_CODES[res.statusCode]
=======
        ? http.STATUS_CODES[status]
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
        : err.stack || err.toString()
      msg = escapeHtml(msg)
        .replace(/\n/g, '<br>')
        .replace(/  /g, ' &nbsp;') + '\n'
    } else {
<<<<<<< HEAD
      res.statusCode = 404
      msg = 'Cannot ' + escapeHtml(req.method) + ' ' + escapeHtml(req.originalUrl || req.url) + '\n'
    }

    debug('default %s', res.statusCode)
=======
      status = 404
      msg = 'Cannot ' + escapeHtml(req.method) + ' ' + escapeHtml(req.originalUrl || req.url) + '\n'
    }

    debug('default %s', status)
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c

    // schedule onerror callback
    if (err && onerror) {
      defer(onerror, err, req, res)
    }

    // cannot actually respond
    if (res._header) {
      return req.socket.destroy()
    }

<<<<<<< HEAD
    send(req, res, res.statusCode, msg)
=======
    send(req, res, status, msg)
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
  }
}

/**
 * Send response.
 *
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {number} status
 * @param {string} body
<<<<<<< HEAD
 * @api private
=======
 * @private
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
 */

function send(req, res, status, body) {
  function write() {
    res.statusCode = status

    // security header for content sniffing
    res.setHeader('X-Content-Type-Options', 'nosniff')

    // standard headers
    res.setHeader('Content-Type', 'text/html; charset=utf-8')
    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))

    if (req.method === 'HEAD') {
      res.end()
      return
    }

    res.end(body, 'utf8')
  }

<<<<<<< HEAD
  if (!req.readable) {
=======
  if (isFinished(req)) {
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
    write()
    return
  }

  // unpipe everything from the request
  unpipe(req)

  // flush the request
<<<<<<< HEAD
  req.once('end', write)
  req.resume()
}

/**
 * Unpipe everything from a stream.
 *
 * @param {Object} stream
 * @api private
 */

/* istanbul ignore next: implementation differs between versions */
function unpipe(stream) {
  if (typeof stream.unpipe === 'function') {
    // new-style
    stream.unpipe()
    return
  }

  // Node.js 0.8 hack
  var listener
  var listeners = stream.listeners('close')

  for (var i = 0; i < listeners.length; i++) {
    listener = listeners[i]

    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
      continue
    }

    // invoke the listener
    listener.call(stream)
  }
}
=======
  onFinished(req, write)
  req.resume()
}
>>>>>>> c2b8175a9f5d027209e2897183af1c023088580c
